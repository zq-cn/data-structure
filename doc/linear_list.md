## 线性表
#### 线性表的定义

线性表是具有相同数据类型的 $n（n ≥ 0）$ 个数据元素的有限序列,其中 n 为表长，当 $n = 0$  时线性表是一个空表。若用L命名线性表，则其一般表示为 L = $（a_1, a_2 , ……, a_{i-1}, a_i ,a_{i+1}, ……, a^n）$ 式中 $a_1$  是唯一的\"第一个\"数据元素，又称表头元素; $a_n$ 是唯一的"最后一个"数据元素，又称表尾元素。  除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来 。   
线性表的特点如下
- 表中元素的个数有限。
- 表中元素具有逻辑上的顺序性，表中元素有其先后次序。
- 表中元素都是数据元素，每个元素都是单个元素。
- 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
- 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。
> 注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。


### 线性表的基本操作
一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下：
> 注意：①基本操作的实现取决于采用哪种存储结构，存储结构不同，算法的实现也不同。 ②“&”表示C++语言中的引用调用，在C语言中采用指针也可达到同样的效果。
> 
数据结构定义
- 定义静态分配内存的线性表

```c
#define MaxSize 50 //定义线性表的最大长度
typedef struct {
    ElemType data[MaxSize]; //顺序表的元素
    int length; //顺序表的当前长度
} SqList; //顺序表的类型定义

```
- 定义动态分配内存的线性表

```c
#define InitSize 100 //表长度的初始定义
typedef struct{
    ElemType *data;
    int MaxSize,length;
} SeqList;
```
InitList(&L):初始化表。构造一个空的线性表。
```c
//code
function InitList(){
}
```
Length (L)：求表长。返回线性表L的长度，即L中数据元素的个数。
```c
//code
function Length(){
}
```
LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素。
```c
//code
function LocateElem(){
}
```
GetElem(L, i):按位查找操作。获取表L中第i个位置的元素的值。
```c
//code
function InitList(){
}
```
Listinsert (&L,i,e):插入操作。在表L中的第i个位置上插入指定元素e。
```c
bool Listinsert(SqList &L, int i, ElemType e) {
    //判断i的范围是否有效
    if (i < 1 || i > L.length) {
        return false;
    }
   //当前存储空间已满，不能插入
    if (L.length >= MaxSize){
        return false;
    }
   //将第i个元素及之后的元素后移
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L;
        data[j - 1];
    }
    //在位置i处放入e
    L.data[i - 1] = e;
    //线性表长度加1
    L.length++;

    return true;
}
```
ListDelete (&L, i, &e):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。
```c
//code
function ListDelete(){
}
```
PrintList (L):输出操作。按前后顺序输出线性表L的所有元素值。
```c
//code
function PrintList(){
}
```
Empty (L):判空操作。若L为空表，则返回true,否则返回false。
```c
//code
function Empty(){
}
```
DestryList(&L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。
```c
//code
function DestryList(){
}
```

### 线性表的顺序表示
#### 顺序表的定义
线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。第 1 个元素存储在线性表的起始位置,第 i 个元素的存储位置后面紧接着存储的是第 i+1 个元素，称 i 为元素 $a_i$在线性表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。 
假设线性表 L 存储的起始位置为 LOC (A) , sizeof (ElemType) 是每个数据元素所占用存储空间的大小，则表 L 所对应的顺序存储如下表所示。

|:数组下标|顺序表|内存地址|
|---|---|---|
|0|$a_1$|LOC(A)|
|1|$a_2$|LOC(A) + sizeof (ElemType)|
|……|……|……|
|i|$a_i$|LOC(A)+(i-1) x sizeof(ElemType))|
|……|……|……|
|n|$a_n$|LOC(A)+(n-1) x sizeof(ElemType))|
|……|……|……|
|MaxSize-1|$a_n$|LOC(A)+(MaxSize-1) x sizeof(ElemType))|

每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，线性表中的任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。 
> 注意：线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的。

假定线性表的元素类型为ElemType,则线性表的顺序存储类型描述为

```c
#define MaxSize 50 //定义线性表的最大长度
typedef struct{
    ElemType data [MaxSize] ; //顺序表的元素
    int length; //顺序表的当前长度
} SqList; //顺序表的类型定义
```
一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。 
而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。

```c
#define InitSize 100 //表长度的初始定义
typedef struct{
    ElemType *data;
    int MaxSize,length;
} SeqList;
```

c的初始动态分配语句为

```c
L data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
```
C++的初始动态分配语句为

```c++
L data=new ElemType[TnitSize];
```
> 动态分配并不是链式存储，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时动态决定。

顺序表最主要的特点是随机访问，即通过首地址和元素序号可在时间$O(1)$内找到指定的元素。  
顺序表的存储密度高，每个结点只存储数据元素。   
顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。  


### 顺序表上基本操作的实现
这里仅讨论顺序表的插入、删除和按值查找的算法，其他基本操作的算法都比较简单
- 插入操作
在顺序表L的第i (l<=i<=L. length+1)个位置插入新元素e。若i的输入不合法，则返回false,表示插入失败；否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾岀一个空位置插入新元素e,顺序表长度增加1,插入成功，返回true。
```c
bool Listinsert(SqList &L, int i, ElemType e) {
    //判断i的范围是否有效
    if (i < 1 || i > L.length) {
        return false;
    }
   //当前存储空间已满，不能插入
    if (L.length >= MaxSize){
        return false;
    }
   //将第i个元素及之后的元素后移
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L;
        data[j - 1];
    }
    //在位置i处放入e
    L.data[i - 1] = e;
    //线性表长度加1
    L.length++;

    return true;
}
```
> 注意：区别顺序表的位序和数组下标。为何判断插入位置是否合法时if语句中用length+1,而移动元素的for语句中只用length?

最好情况：在表尾插入(即i = n+l),元素后移语句将不执行，时间复杂度为 $O(1)$ 。   
最坏情况：在表头插入(即i = 1),元素后移语句将执行巾次，时间复杂度为 $O(n)$ 。   
平均情况：假设 $P_i(P_i =1/(n+1))$ 是在第i个位置上插入一个结点的概率，则在长度为”的线性表中插入一个结点时，所需移动结点的平均次数为     
$$\sum_{k=1}^{n+1} P_1(n-i+1)  =  \sum_{k=1}^{n+1}\frac{1}{n+1}(n-i+1)  = \frac{1}{n+1}\sum_{k=1}^{n+1}  (n-i+1) = \frac{1}{n+1}  \frac{n(n-1)}{2} = \frac{n}{2}$$

$$\sum_{k=1}^n P_1(n-i) =  \sum_{k=1}^n\frac{1}{n}(n-i) = \frac{1}{n}\sum_{k=1}^n  (n-i) = \frac{1}{n}  \frac{n(n-1)}{2} = \frac{n-1}{2}$$  
 
 
